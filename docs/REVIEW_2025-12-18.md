# Hillclimb Repo Review (Comprehensive Handoff)

**Date:** 2025-12-18  
**Scope:** Whole repo: Python CLI + Rust core/CLI + WASM web app + docs/tests/fixtures  
**Audience:** Senior + junior engineering, PM/product, design/UX

---

## 0) Executive Summary (Decisions + Why)

### Decision A — Make Rust (`hc_curve_rs/hc_curve`) the single “source of truth”
**Why:** The repo currently contains *two* full algorithm stacks (Python + Rust). Drift is already possible in subtle semantics (gaps/idle/QC), and it will become unmanageable once we implement many ascent algorithms for comparison. A single canonical core is required for correctness, reproducibility, and research credibility.

**Implications**
- Rust `hc_curve` becomes canonical for ingestion, preprocessing, ascent algorithms, curves/gain-time, and JSON schema.
- Python remains valuable for CLI ergonomics and Matplotlib plotting, but should call Rust (PyO3/maturin wheel preferred; subprocess wrapper acceptable as a first step).

### Decision B — Formalize “ascent algorithm” as an explicit, versioned interface
**Why:** The long-term goal (“implement all known ascent algorithms for broad comparison”) demands strict comparability and stable outputs. Without a contract and versioning, results will shift as thresholds/tuning change, undermining trust.

**Implications**
- Introduce an internal `AscentAlgorithm` interface (Rust-first) with:
  - canonical inputs (time series + sensor channels + provenance)
  - outputs: `gain(t)` + diagnostics + metadata
  - stable parameter hashing and versioned algorithm IDs in JSON

### Decision C — Parser strategy: keep `python-fitparse` short-term, but design a migration off it
**Recommendation:** Do **not** immediately rewrite Python parsing to `fitdecode` unless we plan to keep Python FIT parsing long-term. Instead, prioritize “Rust parsing everywhere”.

**Rationale**
- `python-fitparse` explicitly signals maintainer bandwidth limits and suggests `fitdecode` as an alternative (maintenance risk even if functional today).
- `fitdecode` is a faster, thread-safe rewrite of fitparse with stronger stream fidelity controls.
- If Rust is canonical (and required for WASM anyway), the durable solution is to expose Rust parsing/compute to Python and de-risk Python parser dependency entirely.

**Reference links**
- `python-fitparse` PyPI: https://pypi.org/project/python-fitparse/
- `fitdecode` PyPI: https://pypi.org/project/fitdecode/
- `fitdecode` docs: https://fitdecode.readthedocs.io/

---

## 1) Product Reality: What Users Actually Care About

### Current value prop
- Compute best vertical gain vs duration (“hillclimb curve”).
- Compute minimum time to achieve target gain (“gain-time”).
- Output CSV/PNG and JSON sidecars; web app computes locally (no upload).

### User questions (the “why” behind features)
- “How good is my 5/10/30/60-minute climb capacity?”
- “How fast can I climb 100 m / 500 m / 1000 m?”
- “Why do Strava/Garmin/platforms disagree with my ascent?”
- “How do treadmill incline sessions compare to outdoor climbs?”

### Key product risk: definition drift
Before scaling algorithm count, lock down definitions:
- Are windows allowed to span idle time? session gaps? file overlaps?
- What is “distance” for treadmill incline integration (belt distance vs horizontal distance)?
- How is baro drift handled? How are micro-descents treated?

Deliverable: a spec that defines semantics in plain language + math (see backlog).

---

## 2) Repo Map (How it’s organized)

### Python
- `hc_curve.py`: core parsing + curve math + gain-time + WR logic; includes a small CLI shim (`main_cli()`).
- `hc_cli.py`: Typer CLI orchestration and IO (CSV/JSON/plots).
- `hc_plotting.py`: Matplotlib plotting pipeline.
- `tests/`: lightweight `unittest` suite (synthetic tests only today).

### Rust
- `hc_curve_rs/hc_curve`: core library (parse FIT/GPX, QC, smoothing, idle detection/gating, curves, WR).
- `hc_curve_rs/hc_curve_cli`: Clap CLI + Plotters output + JSON sidecar + caching.
- `hc_curve_rs/hc_curve_web`: Leptos CSR + WASM; Plotly charts via CDN.

### Docs & fixtures
- `Tracklogs/`: example FIT data (treadmill + outdoor).
- `docs/`: specs + usage recipes + verification scripts.
- `notes/`: coordination system (memory/backlog/scrutiny/worklog).

---

## 3) Current Algorithm Pipeline (High-level)

### Ingestion & source selection
Three ascent sources:
1) `runn_total_gain`: cumulative gain from developer fields (preferred if present).
2) `runn_incline`: integrate `max(incline, 0)% * delta_distance`.
3) `altitude`: fallback from `enhanced_altitude`/`altitude`.

Auto mode builds a canonical timeline and can switch sources with a dwell-time heuristic to reduce flapping.

### Altitude-derived ascent (the important bits)
1) Build an “effective altitude path”: reject spikes/outliers; smooth; reduce quantization artifacts.
2) Apply morphological closing to reduce micro-descents.
3) Detect idle using rolling features (speed/cadence/distance advance/vertical speed), then hold/clamp altitude during idle to prevent baro drift being counted as climb.
4) Convert to cumulative ascent using “uprun epsilon” hysteresis (`gain_eps`).

This pipeline is unusually good for noisy real-world data, but it needs a written spec + test vectors because tuning changes materially alter totals.

### Curve computation
Efficient window scanning using precomputed envelope evaluations:
- Python: NumPy vectorization and optional Numba acceleration.
- Rust: optimized library logic with parallel parsing and caching.

### QC censoring
QC can flatten/remove implausible ascent spikes based on duration→gain limits (good, but needs stronger reporting + invariants).

---

## 4) Top Risks / Issues (Prioritized)

### P0 — Dual-core drift (Python vs Rust)
Even with “feature parity”, semantics differ in ways that matter:
- **Meaning of `inactivity_gaps`:** Rust can treat idle segments as inactivity gaps; Python auto mode currently infers “inactivity gaps” primarily from timestamp gaps (not idle segments), and handles session gaps separately.
- This affects window skipping and concave envelope shaping.

**Fix:** write a single spec and align implementations; or (recommended) make Rust canonical and make Python a thin wrapper.

### P0 — `--resample-1hz` can blow up on large gaps
Python resampling fills every integer second between min/max timestamps. Multi-day or multi-file timelines with gaps can generate massive arrays.

**Fix options (pick one):**
- resample per session segment (bounded by gap threshold)
- add a “max gap to fill” guard; require explicit opt-in to fill larger gaps
- refuse to resample when max gap exceeds threshold unless `--force`

### P0 — Ascent definitions aren’t formally versioned
Without versioned algorithm IDs and stable defaults, comparisons across time and across tools aren’t trustworthy.

**Fix:** algorithm registry + parameter hashing in JSON; “persona defaults” (treadmill vs outdoor) documented.

### P1 — Python FIT parsing dependency risk
`python-fitparse` maintainership is flagged on its own PyPI page; we need an off-ramp plan.

**Fix:** either move parsing to Rust core for all surfaces (preferred), or add a parser abstraction in Python and evaluate `fitdecode` as a replacement.

### P1 — QC needs stronger UX and invariants
QC can remove ascent and should:
- report “how much removed” and “where”
- expose diagnostics to web UI/JSON
- enforce monotonicity invariants and log warnings when violated

---

## 5) Tooling / Process (What to do next)

### CI smoke checks (must-have)
Add a GitHub Actions workflow to run on PR/push:
- Python: install requirements; run `python -m unittest discover -s tests -v`
- Rust: `cargo test --workspace` (or at least `cargo check`) under `hc_curve_rs`
- WASM: `cargo check -p hc_curve_web --target wasm32-unknown-unknown`

### Repo hygiene
Resolve untracked local files:
- `AGENTS.md.old`
- `docs/gain_time_spec.md`
Decision: delete, ignore, or commit as canonical docs. (Recommendation: commit docs that are real specs; delete/ignore local editor artifacts.)

---

## 6) “All Ascent Algorithms” Program (Roadmap)

### The core idea
Build an “Algorithm Lab” where multiple ascent algorithms run on the *same canonical samples* and produce directly comparable outputs.

### Deliverables
- CLI: `hc_curve_cli ascent compare` (implemented) and future `ascent export` for canonical inputs
- Web: multi-select algorithms + deltas + “why different” explanations
- JSON: per-algorithm outputs + diagnostics + stable IDs

### Initial algorithm set (high-confidence to implement)
- Existing baseline: effective altitude path + idle gating + uprun epsilon hysteresis.
- Threshold family:
  - per-sample threshold
  - per-run (contiguous climb run) threshold
  - “must climb consistently” (windowed) threshold
- Platform-inspired profiles where behavior is publicly documented:
  - Strava-style thresholding
  - GoldenCheetah hysteresis-style thresholding
  - TwoNav minimum altitude increase

### Research discipline: avoid argument-by-plot
Define an evaluation harness:
- treadmill incline integration as an internal reference (with explicit assumptions about distance semantics)
- sensitivity tests for drift/noise
- regression suite: outputs on `Tracklogs/` stable within tolerances

---

## 7) Role-based Handoff

### Senior Eng
- Own the “single source of truth” migration plan + semantics spec.
- Define `AscentAlgorithm` interface + JSON schema.
- Decide packaging plan (PyO3/maturin wheel vs subprocess wrapper first).

### Junior Eng
- Implement CI workflow.
- Clean Rust warnings; keep `cargo check` clean.
- Add tests around gap semantics and resampling guardrails.

### PM/Product
- Lock personas and select default “truth” algorithms per persona.
- Define what “session” means in-product (one activity vs many; can windows span breaks?).
- Define comparison UX goals (“why do platforms disagree?”).

### Design/UX
- Spec “Algorithm Lab” comparison UI (multi-select, deltas, explanations).
- Improve web error states and parameter transparency (what’s being applied and why).
